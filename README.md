# practice4 Гарбузов Павел БСБО-01-20
---
# 1 задание 
С помощью статического анализатора кода PHP_CodeSniffer были получены следующие результаты.
![изображение](https://github.com/PaulZtx/practice4/assets/36164890/83bc1d50-4308-4641-92b4-06c573a91cfc)

---
# 2 задание 
1. **Использование устаревшего API MySQL:**
   ```php
   $result = mysqli_query($GLOBALS["___mysqli_ston"], $getid );
   ```
   Использование устаревшего API MySQL без обработки возможных ошибок делает код уязвимым для SQL-инъекций. 
   Рекомендуется использовать подготовленные запросы или хотя бы проверять и очищать входные данные.

2. **Небезопасное использование входных данных:**
   ```php
   $id = $_GET[ 'id' ];
   ```
   Входные данные не проверяются на безопасность перед использованием в запросе SQL. Это может привести к SQL-инъекциям.
   Рекомендуется использовать подготовленные запросы или хотя бы функции, такие как `mysqli_real_escape_string`, для обработки входных данных.

3. **Отсутствие обработки ошибок:**
   ```php
   $result = mysqli_query($GLOBALS["___mysqli_ston"], $getid );
   ```
   Отсутствие проверки результата запроса и обработки ошибок делает код менее устойчивым.
   Рекомендуется добавить проверку на успешное выполнение запроса и обработку ошибок.

4. **Отсутствие использования подготовленных выражений:**
   ```php
   $getid  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";
   ```
   Использование строковых конкатенаций для создания SQL-запроса может сделать код уязвимым к инъекциям.
   Рекомендуется использовать подготовленные выражения для обеспечения безопасности.

5. **Использование суперглобального массива без проверки:**
   ```php
   $id = $_GET[ 'id' ];
   ```
   Отсутствие проверки наличия параметра 'id' в массиве `$_GET` может привести к ошибкам, если параметр не передан.

6. **Использование устаревшего MySQL-закрытия соединения:**
   ```php
   ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);
   ```
   Этот код использует устаревший способ закрытия соединения с MySQL. Вместо этого рекомендуется использовать `mysqli_close($GLOBALS["___mysqli_ston"]);`.

7. **Отсутствие безопасности при выводе:**
   ```php
   $html .= '<pre>User ID exists in the database.</pre>';
   ```
   При выводе сообщений на страницу рекомендуется использовать функции безопасности, такие как `htmlspecialchars`, чтобы избежать возможных атак XSS.
---
# 3 задание 
Исправленый участок кода 
```
<?php
if (isset($_GET['Submit'])) {
    $id = $_GET['id'];

    $conn = new mysqli("localhost", "username", "password", "databaseName");
    // Проверка соединения
    if ($conn->connect_error) {
        die("Connection failed: " . $conn->connect_error);
    }
    // Использование подготовленного запроса для предотвращения SQL-инъекций
    $stmt = $conn->prepare("SELECT first_name, last_name FROM users WHERE user_id = ?");
    $stmt->bind_param("s", $id);
    $stmt->execute();
    $result = $stmt->get_result();

    // Получение результатов
    $num = $result->num_rows;
    if ($num > 0) {
       
        $html .= '<pre>Пользовательский ID существует в БД.</pre>';
    } else {

        // Пользователь не найден
        header($_SERVER['SERVER_PROTOCOL'] . ' 404 Not Found');

        $html .= '<pre>Пользовательский ID не существует в БД.</pre>';
    }

    $stmt->close();
    $conn->close();
}

?>
```
---
# 4 задание 
#### При использовании sqlmap, в изначальной программе были найдены следующие уязвимости: 
![image2](https://github.com/PaulZtx/practice4/assets/36164890/91094e58-0894-46f4-b74f-6d69cc9de4a8) 
---
# 5 задание
Запускаем **Burp Suite**, заходим на вкладку *proxy*, открываем браузер.
Теперь нужно авторизироваться на dwva через этот браузер

Походим авторизацию, заходим на `SQL injection`, нажимаем **Submit**

Видим, что все наши действия отображаются в окне **Burp**

![img](https://github.com/PaulZtx/practice4/assets/36164890/d273c5a6-02fc-477f-821c-e3ff79139cfe)

Выбираем последнее действие (Submit на dvwa), и выделяем то, что было введено нами в поле на сайте. Нажимаем правую кнопку мыши и выбираем Send to Intruder.
В открывшемся окне переходим на вкладку Payloads, в которую добавляем инъекции для проверки. 

![img_2](https://github.com/PaulZtx/practice4/assets/36164890/193100ae-756d-498c-9e7e-a6f13a02b343)

Нажимаем Start attack
Начинается процесс отправки запросов с пейлоадами на сервер.
Возьмем инъекцию с наиболей полезной нагрузкой в виде ответа (payload).

![изображение](https://github.com/PaulZtx/practice4/assets/36164890/39d91197-d56e-404a-850c-56f0d6b3dd50)

Проверяем инъекцию.

![img_4](https://github.com/PaulZtx/practice4/assets/36164890/804b0c09-8be2-49c1-8b1a-ebddbeb3b81a)

![img_5](https://github.com/PaulZtx/practice4/assets/36164890/1b747190-1a31-4435-9033-71bbf2e6bd96)




